libqueue
========

libqueue is a C library that provides persistent, named data queues for
programs. Arbitrarily many queues can co-exist, given they have distinct
names.

Arbitrary binary data can be stored. Queues are manipulated using a
stack-based API:

* <code>push()</code> -- append data to the queue
* <code>pop()</code> -- pop data from the queue
* <code>peek()</code> -- retrieve data from a given stack index
* <code>poke()</code> -- replace data at a given stack index

The data itself is stored using libkyotocabinet in a gzip-compressed
hash tree. The storage location is selected in accordance with the XDG
Base Directory Specification and defaults to <code>$XDG\_DATA\_DIR/libqueue</code>.

API Overview
============

```C
struct Queue;

struct QueueData {
  void *v;
  size_t vlen;
};

/*
  Functions return LIBQUEUE_SUCCESS on success, LIBQUEUE_FAILURE on
  error or LIBQUEUE_MEM_ERROR as a special failure type for failed
  memory allocations.
*/

/*
  Open a named queue. The name of the queue is being passed as a string
  <id>. Queues are persistent and data stored previously will still be
  available through the name it was written to. Operations on a queue
  must conclude with a call to queue_close().
  This function ensures that $XDG_DATA_DIR/libqueue exist. If it doesn't
  and cannot be created OR not written to, this function fails.
*/
int queue_open(struct Queue *q, const char *id);

/*
  Push a data object onto the queue. struct QueueData must be filled
  appropriately: d->v is a void* pointer to the data, d->vlen holds the
  data size.
*/
int queue_push(struct Queue *q, struct QueueData *d);

/*
  Pop data from the queue. The library will store the data in the passed
  QueueData struct. d->v must be freed by the user.
*/
int queue_pop(struct Queue *q, struct QueueData *d);

/*
  Writes the number of queue entries to the memory pointed to by *len.
*/
int queue_len(struct Queue *q, int64_t *len);

/*
  Like queue_pop(), but doesn't remove the data object from the queue
  and returns the data at queue position s. Indexing starts from zero
  (0). s must be positive.
*/
int queue_peek(struct Queue *q, int64_t s, struct QueueData *d);

/*
  Like queue_push(), but over-writes the data at queue position s. This
  function cannot be used to append new data to the queue. Indexing
  starts from zero. s must be positive.
*/
int queue_poke(struct Queue *q, int64_t s, struct QueueData *d);

/*
  Closes the queue. Only AFTER this function has been called one can be
  sure that the data has been properly stored. Undefined behaviour may
  occur if the concluding call to this function is omitted.
*/
int queue_close(struct Queue *q);
```

<code>struct Queue</code> is an opaque data type the fields of which
should not be accessed directly. 

Building
========

Dependencies:

* libxdg-basedir
* libkyotocabinet

libqueue uses the GNU autotools for building:

```
./configure --prefix=/your/prefix
make
make install
```

Usage
=====

It's very simple: Use

```C
#include <queue.h>
```

in your C program and link it with

```sh
-lqueue
```
given that libqueue was installed into the default linker search path.

queueutils
==========

The library comes with a number of reference/test/practical utilities
that all operate on the queue named 'queueutils-stack0' to be used on
the command line:

qpush
-----

Pushes all its arguments in onto the queue
</code>queueutils-stack0</code>. Exits with an error code of 0 if the
push was successful and 1 if it wasn't.

qpop
----

Pops the strings from the queue that were pushed using
<code>qpush</code>, on element per call to qpush. If there is no element
to pop, exits with the status code 1. If the pop was successfu, it
prints the string to stdout and exists with the status code 0.
